üßæ Introducci√≥n General del Trabajo Final Integrador
El Trabajo Final Integrador (TFI) de la asignatura Bases de Datos I tiene como finalidad consolidar
los conocimientos adquiridos a lo largo del curso mediante la aplicaci√≥n pr√°ctica de los conceptos
de modelado, normalizaci√≥n, integridad, seguridad y concurrencia en bases de datos relacionales.
Este proyecto propone el desarrollo progresivo de un caso real, articulado con la materia
Programaci√≥n II, para integrar tanto el dise√±o l√≥gico de la base como su implementaci√≥n t√©cnica. A
lo largo de las distintas etapas, se busca simular un entorno profesional de gesti√≥n de datos,
incorporando escenarios de gran volumen, consultas optimizadas, restricciones de seguridad y
situaciones de acceso concurrente.
En la Etapa 1, se construy√≥ el modelo entidad‚Äìrelaci√≥n (DER) y su correspondiente modelo
relacional, definiendo claves primarias, for√°neas, restricciones UNIQUE y CHECK, y dem√°s
constraints que garantizan la integridad y coherencia de los datos.
En la Etapa 2, se implement√≥ la generaci√≥n y carga masiva de datos con SQL puro, alcanzando un
volumen de 10.000 registros consistentes y realistas, distribuidos entre las tablas principales. Se
validaron las cardinalidades, las claves for√°neas y la integridad referencial, asegurando que todas
las FKs apunten a PKs v√°lidas.
La Etapa 3 se centr√≥ en la creaci√≥n de consultas avanzadas y reportes, incorporando JOIN,
GROUP BY, HAVING, subconsultas y vistas. Adem√°s, se analizaron tiempos de ejecuci√≥n con y
sin √≠ndices, evaluando el impacto del dise√±o en el rendimiento de las consultas.
En la Etapa 4, se abordaron los aspectos de seguridad e integridad, mediante la creaci√≥n de
usuarios con privilegios m√≠nimos, el uso de vistas para ocultar informaci√≥n sensible y la
implementaci√≥n de consultas seguras mediante Prepared Statements o procedimientos
almacenados.
Finalmente, la Etapa 5 trat√≥ la concurrencia y las transacciones, simulando accesos simult√°neos,
bloqueos y deadlocks, y comparando los distintos niveles de aislamiento (READ COMMITTED y
REPEATABLE READ). Se implementaron mecanismos de recuperaci√≥n y retry ante conflictos,
reforzando la comprensi√≥n de la atomicidad y el control transaccional.
A lo largo del trabajo se incorpor√≥ el uso responsable de Inteligencia Artificial (IA) como recurso
de tutor√≠a pedag√≥gica, emple√°ndola para revisar decisiones de dise√±o, validar scripts y analizar
estrategias de optimizaci√≥n. El rol de la IA fue de acompa√±amiento reflexivo, sin reemplazar el
razonamiento ni la ejecuci√≥n del estudiante.
En conjunto, este proyecto permiti√≥ integrar de forma pr√°ctica los principios de dise√±o,
implementaci√≥n y mantenimiento de bases de datos relacionales, fortaleciendo la autonom√≠a, la
capacidad anal√≠tica y el pensamiento cr√≠tico en el uso de tecnolog√≠as SQL.
2. Modelo Entidad‚ÄìRelaci√≥n (DER): [DER.png]
Diagrama Entidad‚ÄìRelaci√≥n (DER) 
Entidades principales: Producto, C√≥digoBarras, Marca, Categor√≠a.
Relaci√≥n 1‚ÜíN: Producto pertenece a una Marca y una Categor√≠a.
Relaci√≥n 1‚Üí1: Producto posee un √∫nico C√≥digoBarras.
Se establecen restricciones de integridad referencial y de dominio.
ETAPA 1 ‚Äì Modelado y Definici√≥n de Constraints
Objetivo:
Dise√±ar e implementar el modelo entidad‚Äìrelaci√≥n (DER) y su correspondiente modelo relacional
para el dominio elegido, aplicando correctamente las reglas de integridad, restricciones y claves
necesarias para garantizar la consistencia de los datos.
1. Dominio y Descripci√≥n:
El dominio seleccionado corresponde al tema codigos de barras, donde cada producto pertenece a
una categor√≠a y a una marca, y posee un c√≥digo de barras √∫nico que lo identifica.
El modelo busca reflejar las relaciones reales entre los cat√°logos y los productos, asegurando
integridad, unicidad y control de dominio mediante constraints SQL.
4. Script SQL Implementado:
El script de creaci√≥n contiene:
Definici√≥n de PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK y restricciones de dominio.
Validaci√≥n con inserciones correctas e incorrectas para probar los constraints.
üìÑ Archivo referenciado: SQL_etapa1_producto_barras.sql 
3. Modelo Relacional [modelo_relacional.png]
5. Validaci√≥n Pr√°ctica de Constraints [validacion_constraints.png]
6. Reflexi√≥n sobre las decisiones de dise√±o:
En esta etapa se consolid√≥ la comprensi√≥n del v√≠nculo entre el modelo conceptual y la
implementaci√≥n f√≠sica.
La aplicaci√≥n de restricciones permiti√≥ observar c√≥mo MySQL asegura la integridad incluso ante
intentos de inserci√≥n err√≥nea.
La relaci√≥n 1‚Üí1 entre producto y codigo_barras se logr√≥ mediante la PK=FK, garantizando
unicidad y dependencia total.
Este dise√±o es robusto y preparado para escalar a vol√∫menes mayores en etapas posteriores.
7. Evidencia del uso de IA (Tutor√≠a Pedag√≥gica)
Durante el desarrollo de esta etapa se emple√≥ una herramienta de Inteligencia Artificial (ChatGPT)
con fines educativos, en calidad de tutor de apoyo.
La IA no fue utilizada para generar el c√≥digo completo del proyecto, sino que se le proporcion√≥
una base estructurada del modelo previamente dise√±ada, con el objetivo de revisar decisiones
t√©cnicas y validar las reglas de integridad definidas en el esquema relacional.
A partir de la estructura inicial, se trabaj√≥ de forma colaborativa para completar validaciones,
corregir inconsistencias sint√°cticas y perfeccionar los constraints del dominio ‚ÄúC√≥digo de barras‚Äù,
garantizando que cada producto tuviera un √∫nico c√≥digo asociado, con un formato de 13 d√≠gitos y
relaciones 1‚Üí1 correctamente implementadas mediante PRIMARY KEY = FOREIGN KEY.
En s√≠ntesis, la intervenci√≥n de la IA permiti√≥ pulir el dise√±o y reforzar la comprensi√≥n conceptual
de los mecanismos de integridad en MySQL, actuando como una herramienta de acompa√±amiento
pedag√≥gico, sin reemplazar el trabajo ni las decisiones del estudiante.
üìÑ Anexo IA: ver video complementario ‚ÄúIA ‚Äì Aplicaci√≥n‚Äù.
ETAPA 2 ‚Äì Generaci√≥n y Carga de Datos Masivos con SQL Puro
Objetivo:
Generar un conjunto de datos masivo, coherente y reproducible, utilizando exclusivamente SQL,
de manera que la base pueda ser utilizada en las etapas siguientes (consultas avanzadas, seguridad
y concurrencia).
Se busca simular un entorno de gesti√≥n de productos realista, garantizando integridad referencial,
unicidad de c√≥digos de barras y consistencia en los dominios de cada tabla.
1. Descripci√≥n conceptual del mecanismo:
Para la carga masiva se dise√±√≥ un proceso basado en la combinaci√≥n controlada de tablas semilla,
en este caso los cat√°logos categoria, marca y una tabla auxiliar tmp_nombres_producto.
A partir de estos cat√°logos, se generaron 10 000 productos distintos mediante la instrucci√≥n
INSERT ‚Ä¶ SELECT junto con funciones SQL como RAND(), MOD() y ROW_NUMBER().
El mecanismo garantiza:
Integridad referencial, ya que cada producto referencia categor√≠as y marcas existentes.
Unicidad de c√≥digo de barras, con un formato GTIN-13 generado autom√°ticamente a partir del
id del producto.
Valores realistas en atributos num√©ricos, aplicando m√°rgenes aleatorios entre precio y costo, y
un stock generado dentro de un rango controlado.
Reproducibilidad, dado que el proceso puede repetirse manteniendo la coherencia y las
proporciones originales.
2. Script SQL implementado
El script ejecutado utiliza una estructura secuencial:
Inserci√≥n de cat√°logos base (categoria, marca).
Creaci√≥n de la tabla temporal tmp_nombres_producto con 200 nombres de referencia.
Inserci√≥n masiva en producto combinando los cat√°logos y los nombres mediante una consulta
recursiva que multiplica los registros hasta alcanzar 10 000 filas.
Generaci√≥n autom√°tica de los c√≥digos de barras asociados, respetando la relaci√≥n 1‚Üí1 con
producto.
üìÑ Archivo referenciado: SQL_etapa2_carga_masiva.sql [verificacion_consistencia_carga_masiva.png]
üìò Fragmento representativo del script:
4. Reflexi√≥n sobre el proceso:
Esta etapa permiti√≥ aplicar el razonamiento l√≥gico y las t√©cnicas de automatizaci√≥n en SQL
para simular una base de datos de gran escala.
Se comprob√≥ la importancia de mantener relaciones consistentes y restricciones de integridad
durante la generaci√≥n masiva de datos.
El dominio ‚ÄúC√≥digo de barras‚Äù result√≥ adecuado para representar escenarios reales de
inventario y control log√≠stico, asegurando unicidad, trazabilidad y coherencia entre las
entidades.
5. Evidencia del uso de IA (Tutor√≠a Pedag√≥gica):
Se utiliz√≥ una herramienta de Inteligencia Artificial (ChatGPT) como tutor pedag√≥gico para
acompa√±ar el desarrollo de la carga masiva y la validaci√≥n del c√≥digo SQL.
Su rol fue el de asistencia t√©cnica y metodol√≥gica, ayudando a revisar la estructura del script, el
orden l√≥gico de ejecuci√≥n, y la aplicaci√≥n de buenas pr√°cticas de escritura y alcance de c√≥digo
(scope) para mantener un flujo de inserci√≥n controlado y reproducible.
A partir de un script base elaborado por el estudiante, se implementaron metodolog√≠as de trabajo
modular, separaci√≥n de bloques (cat√°logos, secuencias, inserciones, verificaciones) y uso de
variables parametrizadas (@TARGET_ROWS, @CATS, @MKS) que permiten escalar el
volumen sin alterar la coherencia del modelo.
La IA no gener√≥ el trabajo completo, sino que asisti√≥ en la correcci√≥n de detalles sint√°cticos, la
interpretaci√≥n de errores y la verificaci√≥n del comportamiento de las inserciones a gran escala.
Este acompa√±amiento fortaleci√≥ el razonamiento l√≥gico, la comprensi√≥n del alcance del c√≥digo
(scope) y la capacidad de dise√±o escalable en SQL, manteniendo siempre un rol activo y reflexivo
del estudiante en la implementaci√≥n final.